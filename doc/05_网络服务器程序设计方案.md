# 网络服务器程序设计方案

理查德·史蒂文斯在 《Unix网络编程》 中介绍了十来种当时流行的并发网络编程方案。但现在离当时已经过去了几十年了，网络编程也有了很多大的改进。

## 进程模型与I/O 模型

网络编程一个重要的目标是如何设计一个高性能的服务器，而编写一个单一的高性能网络服务关键之一就是采用什么并发模型，并发模型又有两个关键的设计点：

- 服务器如何管理连接
- 服务器如何处理请求

以上两个设计方案最终都要和操作系统的进程模型和I/O模型相关联。

对于进程模型主要有三种：

- 单进程
- 多进程
- 多线程

对于I/O模型常见的有五种：

- 阻塞式I/O，最流行的I/O模型，默认情形下，所有套接字都是阻塞的。
- 非阻塞式I/O，当所请求的I/O操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误。应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往耗费大量CPU时间，不过这种模型偶尔也会遇到，通常是在专门提供某一种功能的系统中才有。
- I/O复用（select和poll），可以调用select或poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上。
- 信号驱动式I/O（SIGIO），用信号，让内核在描述符就绪时发送SIGIO信号通知我们。
- 异步I/O（POSIX的aio_系列函数），告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。

## 高性能网络并发模型

在陈硕的《Linux多线程网络服务端编程》书籍中，作者总结了12种常见的网络程序设计方案：

![network_model](images/networkd_model.png)

### accept+read/write

这种并不是并发服务器，这种方案不适合长连接，因为同一个服务器同一时间只能服务一个客户端。我们之前实现的回射服务器就是采用这种方案。

### accept+fork 与 prefork

`accept+fork` 是比较传统的 Unix 并发网络编程方案，也称 process-per-connetion(PPC)。这种方案每个连接都必须调用 `fork` 产生一个子进程进程来服务一个连接，适合并发长连接且连接数不大的场景，比如数据库服务器。

而 `prefork` 是对上面这种方案的优化。由于 `fork` 进程是有比较大的开销的，当连接进来时，首先需要 `fork` 一个子进程，所以响应速度不会很快，为了解决这个问题，就需要提前创建进程（pre-fork）。提前创建的进程可以在新连接建立的时候省去 `fork` 进程的操作。

### accept+thread 与 pre threaded

`accept+thread`，又名 thread-per-connection(TPC)。顾名思义，就是指每新建一个连接就创建一个新线程去处理。与上面的多进程方案相对，线程更加轻量级，创建线程的开销也会更少。在 Java 引入NIO之前，Java 的网络编程都是这种方案实现的。这种方案的引入了CPU线程调度和上下文切换的新问题，本质上与 `accept+fork` 方案基本类似，其受线程数量的限制，并发连接在几百个的情况下还行，但是如果上千个连接负担会不小。

而 `pre threaded` 和 `prefork` 也类似，提前创建线程，省去了新连接到来时创建线程的操作。

### reactor

以上几种方案都是阻塞式的网络编程方案，程序流程通常会阻塞在 `read()` 操作上，但TCP是一个全双工的协议，需要同时支持 `read()` 和 `write()` 操，即同一时间可能既要接收数据，也可能需要发送数据。

上面集中方案另一个问题就是需要为每个连接都分配一个线程或一个进程，且在连接结束后需要释放相应的资源，这样也就造成了系统资源的浪费，虽然可以使用引入资源池来达到资源复用，但并没有解决如何高效的处理多个连接业务的问题。

为了解决上面的问题，一个更好的方法就是采用 **I/O多路复用** 技术。这种方案的技术特点有以下几点：

- 多个连接共用一个阻塞对象，进程只需要在一个阻塞对象上等待，这种技术实现有 `select`、`poll`、`epool`、`kqueue`等。
- I/O 复用复用的不是 I/O 连接，而是线程。当有新连接建立或某条连接有新数据到来时，操作系统会通知进程，进程会立马从阻塞状态返回，开始业务处理。
- 使用 `select/poll` 几乎肯定需要配合非阻塞式I/O，那么这就需要使用到应用层的 `buffer`。

I/O 多路复用结合线程池可以很好的解决前面几种方案遇到的问题，这种模式另一个名字叫做 `Reactor`，中文叫做“反应堆”。所谓“反应堆”指的是“事件反应”，当某个事件，如当连接建立、数据可读或可写时，就会有相应的“事件反应”。

Reactor 的意义在于如何将事件分发到用户提供的处理函数上面，并保持网络部分的通用代码不变，独立与用户的业务逻辑。其通常包含 Reactor和处理资源池（线程池或进程池）两个部分，Reactor负责监听和事件分配，资源池负责处理事件。这种方案在不同的场景下是灵活多变得，因为Reactor和资源池的数量也是可以变化的，Reactor可以有一个或多个，相应的进程或线程也可以变化。

Reactor通过与进程、线程的配置组合可以产生以下这些并发模型：

1. 单 Reactor 单进程/线程
    - select/poll，适合I/O密集型应用，没有利用多核优势，所以不太适合CPU密集型应用。

2. 单 Reactor 多线程
    - reactor + pthread-per-task，可以利用多核优势，把计算任务交给线程去做，但这种方案无法保证计算结果的次序。
    - reactor + worker thread，为了解决上面方案的次序问题，将每个连接的请求固定到某个线程上面去计算。
    - reactor + thread poll，为了解决每个连接都创建一个新线程的问题，引入了线程池，并且可以固定线程大小。

3. 多 Reactor 多进程/线程
    - reactor in threads，多线程reactor解决方案，把reactor分为 mainReactor 和 subReactor，mainReactor负责 `accept` 接受新连接，subReactor 负责处理连接建立后的各种事件。采用这种方案的开源项目有 netty、muduo、memcache等。
    - reactor in process，多进程reactor解决方案，著名的系统 Nginx 就是采用的这种方案。
    - reactor + thread pool，上面两种方案的结合体，可以用多个 reactor 来处理I/O，同时使用线程池来处理计算任务。